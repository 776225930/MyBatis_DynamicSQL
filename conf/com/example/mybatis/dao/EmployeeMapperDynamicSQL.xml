<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="com.example.mybatis.dao.EmployeeMapperDynamicSQL">
     <!-- 
    if:判断
 	choose (when, otherwise):带了break的swtich-case
	如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个
	trim (where, set):字符串截取(where set)
	foreach
      -->
   <!-- public List<Employee> getEmpsByComditionIf(Employee employee); -->
    <select id="getEmpsByComditionIf" resultType="com.example.mybatis.bean.Employee">
         select * from tbl_employee  
         <!-- test:判断表达式(OGNL)  遇见特殊符号写转义字符 -->
         <where>
         <if test="id!=null">
              id=#{id}
         </if>
         <if test="lastName!=null and lastName!=''">
          and last_name like #{lastName}
         </if>
          <if test="email!=null and email.trim()!=&quot;&quot;">
          and email=#{email}
          </if>
          <!-- OGNL会进行字符串与数字类型转换 -->
          <if test="gender==0 or gender==1">
          and gender=#{gender}
          </if>
          </where>
    </select>
    
    <!-- 自定义字符串的截取规则 -->
    <!-- public List<Employee> getEmpsByComditionTrim(Employee employee); -->
     <select id="getEmpsByComditionTrim" resultType="com.example.mybatis.bean.Employee">
      select * from tbl_employee 
      where 
      <!-- 最后多出的and或者or where标签不能解决 
       prefix:前缀:trim标签体中是整个字符串拼串后的结果,
        prefix给拼串后的结果加一个前缀 
       prefixOverrides:前缀覆盖:去掉整个字符串前面多余的字符  
       suffix  
       suffixOverrides -->
      <trim suffixOverrides="and">
         <if test="id!=null">
              id=#{id} and
         </if>
         <if test="lastName!=null and lastName!=''">
           last_name like #{lastName} and
         </if>
          <if test="email!=null and email.trim()!=&quot;&quot;">
           email=#{email} and
          </if>
          <!-- OGNL会进行字符串与数字类型转换 -->
          <if test="gender==0 or gender==1">
          and gender=#{gender}
          </if>
      </trim>
     </select>
    
    <!-- public List<Employee> getEmpsByComditionChoose(Employee employee); -->
      <select id="getEmpsByComditionChoose" resultType="com.example.mybatis.bean.Employee">
           select * from tbl_employee
           <where>
           <!-- 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个 -->
           <choose>
              <when test="id!=null">
                  id=#{id}
              </when>
              <when test="lastName!=null">
                  last_Name=#{lastName}
              </when>
              <when test="email!=null">
                  email=#{email}
              </when>
              <otherwise>
                 gender=0<!-- 1=1 -->
              </otherwise>
           </choose>
           </where> 
      </select>
      
      <!-- public void updateEmp(Employee employee); -->
      <select id="updateEmp" resultType="com.example.mybatis.bean.Employee">
       update tbl_employee 
       <set> 
       <if test="lastName!=null">
       last_name=#{lastName},
       </if>
       <if test="email!=null">
       email=#{email},
       </if>
       <if test="gender!=null">
       gender=#{gender}
       </if>
       </set>
       where id=#{id}
      </select>
      <!-- public List<Employee> getEmpsByComditionForeach(List<Integer> ids); -->
      <select id="getEmpsByComditionForeach" resultType="com.example.mybatis.bean.Employee">
               select * from tbl_employee  
        <!--
	 		collection：指定要遍历的集合：
	 		list类型的参数会特殊处理封装在map中，map的key就叫list
	 		item：将当前遍历出的元素赋值给指定的变量
	 		separator:每个元素之间的分隔符
	 		open：遍历出所有结果拼接一个开始的字符
	 		close:遍历出所有结果拼接一个结束的字符
	 		index:索引。遍历list的时候是index就是索引，item就是当前值
	 				      遍历map的时候index表示的就是map的key，item就是map的值
	 		
	 		#{变量名}就能取出变量的值也就是当前遍历出的元素
	 	  -->
	 	  <foreach collection="ids" item="item_id" separator="," open="where id in(" close=")">
	 	     #{item_id}
	 	  </foreach>
      </select>
      
      <!-- public void addEmps(@Param("emps")List<Employee> emps); -->
      <!--MySQL下批量保存：可以foreach遍历   mysql支持values(),(),()语法-->
      <insert id="addEmps">
      insert into tbl_employee(last_name,email,gender,d_id)
		values
		<foreach collection="emps" item="emp" separator=","></foreach>
			(#{emp.lastName},#{emp.email},#{emp.gender},#{emp.dept.id})
      </insert> 
      <!-- 这种方式需要数据库连接属性allowMultiQueries=true；
	 	这种分号分隔多个sql可以用于其他的批量操作（删除，修改） 
      <insert id="addEmps">
          <foreach collection="emps" item="emp" separator=";">
            insert into tbl_employee(last_name,email,gender,d_id) 
            values (#{emp.lastName},#{emp.email},#{emp.gender},#{emp.dept.id})
           </foreach>
      </insert>-->
      
      <insert id="addEmps" databaseId="oracle">
         
      </insert>
  </mapper>